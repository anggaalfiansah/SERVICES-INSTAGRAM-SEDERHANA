"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.outgoingUnsubscribeFlow = exports.outgoingSubscribeFlow = exports.outgoingPublishFlow = exports.outgoingPingFlow = exports.outgoingDisconnectFlow = exports.outgoingConnectFlow = void 0;
const mqtt_packet_1 = require("../mqtt.packet");
const mqtt_utilities_1 = require("../mqtt.utilities");
const packet_writer_1 = require("../packets/packet-writer");
const mqtt_constants_1 = require("../mqtt.constants");
const errors_1 = require("../errors");
function outgoingConnectFlow(options) {
    const finalOptions = {
        protocolLevel: 4,
        clientId: 'mqtt_' + Math.round(Math.random() * 10e5),
        clean: true,
        keepAlive: 60,
        protocolName: 'MQTT',
        ...options,
    };
    return (success, error) => ({
        start: () => packet_writer_1.defaultWrite(mqtt_constants_1.PacketType.Connect, finalOptions),
        accept: mqtt_utilities_1.isConnAck,
        next: (res) => (res.isSuccess ? success(res) : error(res.errorName)),
    });
}
exports.outgoingConnectFlow = outgoingConnectFlow;
function outgoingDisconnectFlow() {
    return success => ({
        start: () => {
            success();
            return packet_writer_1.defaultWrite(mqtt_constants_1.PacketType.Disconnect);
        },
    });
}
exports.outgoingDisconnectFlow = outgoingDisconnectFlow;
function outgoingPingFlow() {
    return success => ({
        start: () => packet_writer_1.defaultWrite(mqtt_constants_1.PacketType.PingReq),
        accept: mqtt_utilities_1.isPingResp,
        next: () => success(),
    });
}
exports.outgoingPingFlow = outgoingPingFlow;
function outgoingPublishFlow(message, _identifier) {
    const id = _identifier !== null && _identifier !== void 0 ? _identifier : mqtt_packet_1.generateIdentifier();
    let receivedPubRec = false;
    return success => ({
        start: () => {
            const packet = packet_writer_1.defaultWrite(mqtt_constants_1.PacketType.Publish, {
                topic: message.topic,
                payload: mqtt_utilities_1.toBuffer(message.payload),
                qos: message.qosLevel || 0,
                retain: message.retained || false,
                duplicate: message.duplicate || false,
                identifier: message.qosLevel ? id : undefined,
            });
            if (!message.qosLevel)
                success(message);
            return packet;
        },
        accept: (packet) => {
            if (message.qosLevel === 1 && mqtt_utilities_1.isPubAck(packet)) {
                return packet.identifier === id;
            }
            else if (message.qosLevel === 2) {
                if (mqtt_utilities_1.isPubRec(packet)) {
                    return packet.identifier === id;
                }
                else if (receivedPubRec && mqtt_utilities_1.isPubComp(packet)) {
                    return packet.identifier === id;
                }
            }
            return false;
        },
        next: (packet) => {
            if (mqtt_utilities_1.isPubAck(packet) || mqtt_utilities_1.isPubComp(packet)) {
                success(message);
            }
            else if (mqtt_utilities_1.isPubRec(packet)) {
                receivedPubRec = true;
                return packet_writer_1.defaultWrite(mqtt_constants_1.PacketType.PubRel, { identifier: id });
            }
        },
    });
}
exports.outgoingPublishFlow = outgoingPublishFlow;
function outgoingSubscribeFlow(subscription, identifier) {
    const id = identifier !== null && identifier !== void 0 ? identifier : mqtt_packet_1.generateIdentifier();
    return (success, error) => ({
        start: () => packet_writer_1.defaultWrite(mqtt_constants_1.PacketType.Subscribe, {
            identifier: id,
            subscriptions: [{ qos: subscription.qosLevel || 0, topic: subscription.topic }],
        }),
        accept: (packet) => mqtt_utilities_1.isSubAck(packet) && packet.identifier === id,
        next: (packet) => {
            if (!packet.anyError) {
                success(packet.returnCodes[0]);
            }
            else {
                error(new errors_1.SubscribeError(`Failed to subscribe to ${subscription.topic} - Return Codes: ${packet.returnCodes.join(', ')}`));
            }
        },
    });
}
exports.outgoingSubscribeFlow = outgoingSubscribeFlow;
function outgoingUnsubscribeFlow(subscription, identifier) {
    const id = identifier !== null && identifier !== void 0 ? identifier : mqtt_packet_1.generateIdentifier();
    return success => ({
        start: () => packet_writer_1.defaultWrite(mqtt_constants_1.PacketType.Unsubscribe, {
            identifier: id,
            topics: [subscription.topic],
        }),
        accept: packet => mqtt_utilities_1.isUnsubAck(packet) && packet.identifier === id,
        next: () => success(),
    });
}
exports.outgoingUnsubscribeFlow = outgoingUnsubscribeFlow;
//# sourceMappingURL=outgoing.flows.js.map