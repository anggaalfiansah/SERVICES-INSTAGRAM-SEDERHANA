"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createFlowCounter = exports.stringifyObject = exports.createDefaultPacketLogger = exports.toMqttTopicFilter = exports.toBuffer = exports.notUndefined = exports.resolve = exports.isPingResp = exports.isUnsubAck = exports.isSubAck = exports.isPubComp = exports.isPubRel = exports.isPubRec = exports.isPubAck = exports.isPublish = exports.isConnAck = exports.nullOrUndefined = exports.extractParams = exports.removeUntil = exports.expectRemainingLength = exports.matchTopic = void 0;
const packets_1 = require("./packets");
const mqtt_constants_1 = require("./mqtt.constants");
function matchTopic(baseTopic, incomingTopic) {
    if (baseTopic.length === incomingTopic.length && baseTopic === incomingTopic)
        return true;
    const parts = baseTopic.split('+');
    let remaining = incomingTopic;
    for (const part of parts) {
        if (!remaining.startsWith(part)) {
            return false;
        }
        remaining = removeUntil(remaining.substring(part.length), '/');
    }
    return true;
}
exports.matchTopic = matchTopic;
function expectRemainingLength(length, expected) {
    if (!expected) {
        expected = 0;
    }
    if (length !== expected) {
        throw new Error(`Expected remaining length to be ${expected} but got ${length}`);
    }
}
exports.expectRemainingLength = expectRemainingLength;
function removeUntil(input, char) {
    return input.substring(Math.max(input.indexOf(char), 0));
}
exports.removeUntil = removeUntil;
function extractParams(template, topic) {
    const templateParts = template.split('/');
    const topicParts = topic.split('/');
    const params = {};
    for (let i = 0; i < Math.min(templateParts.length, topicParts.length); i++) {
        if (templateParts[i].startsWith(':')) {
            params[templateParts[i].substring(1)] = topicParts[i];
        }
    }
    return params;
}
exports.extractParams = extractParams;
const nullOrUndefined = (input) => input == undefined;
exports.nullOrUndefined = nullOrUndefined;
const isConnAck = (target) => target instanceof packets_1.ConnectResponsePacket;
exports.isConnAck = isConnAck;
const isPublish = (target) => target instanceof packets_1.PublishRequestPacket;
exports.isPublish = isPublish;
const isPubAck = (target) => target instanceof packets_1.PublishAckPacket;
exports.isPubAck = isPubAck;
const isPubRec = (target) => target instanceof packets_1.PublishReceivedPacket;
exports.isPubRec = isPubRec;
const isPubRel = (target) => target instanceof packets_1.PublishReleasePacket;
exports.isPubRel = isPubRel;
const isPubComp = (target) => target instanceof packets_1.PublishCompletePacket;
exports.isPubComp = isPubComp;
const isSubAck = (target) => target instanceof packets_1.SubscribeResponsePacket;
exports.isSubAck = isSubAck;
const isUnsubAck = (target) => target instanceof packets_1.UnsubscribeResponsePacket;
exports.isUnsubAck = isUnsubAck;
const isPingResp = (target) => target instanceof packets_1.PingResponsePacket;
exports.isPingResp = isPingResp;
async function resolve(resolvable) {
    return typeof resolvable === 'object' ? resolvable : await resolvable();
}
exports.resolve = resolve;
function notUndefined(value) {
    return typeof value !== 'undefined';
}
exports.notUndefined = notUndefined;
function toBuffer(value) {
    return typeof value === 'string' ? Buffer.from(value) : value;
}
exports.toBuffer = toBuffer;
const paramRegex = /\/:[A-Za-z-_0-9]+/g;
function toMqttTopicFilter(paramString) {
    if (paramString.match(paramRegex)) {
        return [paramString.replace(paramRegex, '/+'), paramString];
    }
    return [paramString];
}
exports.toMqttTopicFilter = toMqttTopicFilter;
function createDefaultPacketLogger(debug) {
    return (packetType, packetInfo) => {
        if (packetType !== mqtt_constants_1.PacketType.PingReq && packetType !== mqtt_constants_1.PacketType.PingResp) {
            debug(`Write ${mqtt_constants_1.packetTypeToString(packetType)} ${stringifyObject(packetInfo)}`);
        }
    };
}
exports.createDefaultPacketLogger = createDefaultPacketLogger;
function stringifyObject(obj) {
    return `${obj.constructor === Object ? '' : `${obj.constructor.name} `}{${Object.entries(obj)
        .filter(([, v]) => typeof v !== 'undefined')
        .map(([k, v]) => `${k}: ${stringifyValue(v)}`)
        .join(', ')}}`;
}
exports.stringifyObject = stringifyObject;
function stringifyValue(value) {
    if (typeof value === 'object') {
        if (value === null) {
            return '<null>';
        }
        else if (Array.isArray(value)) {
            return `<Array { len: ${value.length}}>`;
        }
        else if (Buffer.isBuffer(value)) {
            return `<Buffer { bytes: ${value.byteLength}}>`;
        }
        else if (value.constructor !== Object) {
            return `<${value.constructor.name}>`;
        }
        else {
            return '{...}';
        }
    }
    else {
        return typeof value === 'string' ? `"${value}"` : String(value);
    }
}
function createFlowCounter() {
    if (!globalThis.BigInt) {
        let count = 0;
        return {
            next() {
                return ++count;
            },
        };
    }
    let count = BigInt(0);
    return {
        next() {
            return (count += BigInt(1));
        },
    };
}
exports.createFlowCounter = createFlowCounter;
//# sourceMappingURL=mqtt.utilities.js.map