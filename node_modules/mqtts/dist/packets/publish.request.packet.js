"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.readPublishRequestPacket = exports.writePublishRequestPacket = exports.PublishRequestPacket = void 0;
const mqtt_packet_1 = require("../mqtt.packet");
const errors_1 = require("../errors");
const mqtt_utilities_1 = require("../mqtt.utilities");
class PublishRequestPacket extends mqtt_packet_1.IdentifierPacket {
    constructor(flags, topic, identifier, payload) {
        super(identifier !== null && identifier !== void 0 ? identifier : -1);
        this.flags = flags;
        this.topic = topic;
        this.payload = payload;
        if ((flags & 0b0110) >> 1 > 2)
            throw new Error('Invalid QoS');
    }
    get duplicate() {
        return !!(this.flags & 0b1000);
    }
    get qos() {
        return ((this.flags & 0b0110) >> 1);
    }
    get retain() {
        return !!(this.flags & 0b0001);
    }
}
exports.PublishRequestPacket = PublishRequestPacket;
function writePublishRequestPacket(stream, options) {
    var _a, _b;
    options.qos = (_a = options.qos) !== null && _a !== void 0 ? _a : 0;
    stream.writeString(options.topic);
    if (options.qos > 2)
        throw new Error('Unsupported QoS');
    if (options.qos > 0) {
        if (!options.identifier)
            throw new Error('Expected identifier for QoS != 0');
        stream.writeWord(options.identifier);
    }
    stream.write(mqtt_utilities_1.toBuffer((_b = options.payload) !== null && _b !== void 0 ? _b : Buffer.alloc(0)));
    return {
        flags: (Number(!!options.duplicate) << 3) | ((options.qos & 0x3) << 1) | Number(!!options.retain),
        identifier: options.identifier,
    };
}
exports.writePublishRequestPacket = writePublishRequestPacket;
function readPublishRequestPacket(stream, remainingLength, flags) {
    const startPos = stream.position;
    const topic = stream.readString();
    const identifier = flags & 0b0110 ? stream.readWord() : undefined;
    const payloadLength = remainingLength - (stream.position - startPos);
    if (payloadLength > stream.length - stream.position)
        throw new errors_1.EndOfStreamError();
    const payload = payloadLength > 0 ? stream.read(payloadLength) : Buffer.alloc(0);
    return new PublishRequestPacket(flags, topic, identifier, payload);
}
exports.readPublishRequestPacket = readPublishRequestPacket;
//# sourceMappingURL=publish.request.packet.js.map