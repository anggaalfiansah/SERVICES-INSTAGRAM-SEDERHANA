"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultPacketWriteMap = exports.defaultWrite = exports.PacketWriter = void 0;
const mqtt_constants_1 = require("../mqtt.constants");
const connect_request_packet_1 = require("./connect.request.packet");
const packet_stream_1 = require("../packet-stream");
const publish_request_packet_1 = require("./publish.request.packet");
const publish_ack_packet_1 = require("./publish.ack.packet");
const publish_received_packet_1 = require("./publish.received.packet");
const publish_release_packet_1 = require("./publish.release.packet");
const publish_complete_packet_1 = require("./publish.complete.packet");
const subscribe_request_packet_1 = require("./subscribe.request.packet");
const unsubscribe_request_packet_1 = require("./unsubscribe.request.packet");
const ping_request_packet_1 = require("./ping.request.packet");
const ping_response_packet_1 = require("./ping.response.packet");
class PacketWriter {
    constructor(logger, writeMap = exports.DefaultPacketWriteMap) {
        this.logger = logger;
        this.writeMap = writeMap;
    }
    write(type, options) {
        var _a, _b;
        const packetStream = packet_stream_1.PacketStream.empty();
        const fn = this.writeMap[type];
        if (!fn) {
            throw new Error('No packet function found');
        }
        const result = fn(packetStream, options);
        if (result.flags && (result.flags < 0 || result.flags > 0xf)) {
            throw new Error('Invalid flags');
        }
        this.logger.logPacketWrite(type, { ...options, flags: (_a = result.flags) !== null && _a !== void 0 ? _a : 0, identifier: result.identifier });
        const finalStream = packet_stream_1.PacketStream.empty();
        finalStream.writeByte((type << 4) | ((_b = result.flags) !== null && _b !== void 0 ? _b : 0));
        //if (packetStream.length === 0) return finalStream.data;
        return finalStream.writeVariableByteInteger(packetStream.length).write(packetStream.data).data;
    }
}
exports.PacketWriter = PacketWriter;
function defaultWrite(type, options) {
    return {
        type,
        options,
    };
}
exports.defaultWrite = defaultWrite;
exports.DefaultPacketWriteMap = {
    [mqtt_constants_1.PacketType.Connect]: connect_request_packet_1.writeConnectPacket,
    [mqtt_constants_1.PacketType.Publish]: publish_request_packet_1.writePublishRequestPacket,
    [mqtt_constants_1.PacketType.PubAck]: publish_ack_packet_1.writePublishAckPacket,
    [mqtt_constants_1.PacketType.PubRec]: publish_received_packet_1.writePublishReceivedPacket,
    [mqtt_constants_1.PacketType.PubRel]: publish_release_packet_1.writePublishReleasePacket,
    [mqtt_constants_1.PacketType.PubComp]: publish_complete_packet_1.writePublishCompletePacket,
    [mqtt_constants_1.PacketType.Subscribe]: subscribe_request_packet_1.writeSubscribePacket,
    [mqtt_constants_1.PacketType.Unsubscribe]: unsubscribe_request_packet_1.writeUnsubscribePacket,
    [mqtt_constants_1.PacketType.PingReq]: ping_request_packet_1.writePingRequestPacket,
    [mqtt_constants_1.PacketType.PingResp]: ping_response_packet_1.writePingResponsePacket,
};
//# sourceMappingURL=packet-writer.js.map