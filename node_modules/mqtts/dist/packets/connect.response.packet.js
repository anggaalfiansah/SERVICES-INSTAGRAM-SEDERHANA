"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectReturnCode = exports.readConnectResponsePacket = exports.ConnectResponsePacket = void 0;
const mqtt_utilities_1 = require("../mqtt.utilities");
class ConnectResponsePacket {
    constructor(ackFlags, returnCode) {
        this.ackFlags = ackFlags;
        this.returnCode = returnCode;
    }
    get sessionPresent() {
        return !!(this.ackFlags & 0x1);
    }
    get isSuccess() {
        return this.returnCode === ConnectReturnCode.Accepted;
    }
    get errorName() {
        var _a, _b;
        return (_b = (_a = Object.entries(ConnectReturnCode).find(([, v]) => v === this.returnCode)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : 'Unknown';
    }
}
exports.ConnectResponsePacket = ConnectResponsePacket;
function readConnectResponsePacket(stream, remaining) {
    mqtt_utilities_1.expectRemainingLength(remaining, 2);
    const ack = stream.readByte();
    const returnCode = stream.readByte();
    if (ack > 1) {
        throw new Error('Invalid ack');
    }
    else if (returnCode > 5) {
        throw new Error('Invalid return code');
    }
    return new ConnectResponsePacket(ack, returnCode);
}
exports.readConnectResponsePacket = readConnectResponsePacket;
var ConnectReturnCode;
(function (ConnectReturnCode) {
    ConnectReturnCode[ConnectReturnCode["Accepted"] = 0] = "Accepted";
    ConnectReturnCode[ConnectReturnCode["UnacceptableProtocolVersion"] = 1] = "UnacceptableProtocolVersion";
    ConnectReturnCode[ConnectReturnCode["IdentifierRejected"] = 2] = "IdentifierRejected";
    ConnectReturnCode[ConnectReturnCode["ServerUnavailable"] = 3] = "ServerUnavailable";
    ConnectReturnCode[ConnectReturnCode["BadUsernameOrPassword"] = 4] = "BadUsernameOrPassword";
    ConnectReturnCode[ConnectReturnCode["NotAuthorized"] = 5] = "NotAuthorized";
})(ConnectReturnCode = exports.ConnectReturnCode || (exports.ConnectReturnCode = {}));
//# sourceMappingURL=connect.response.packet.js.map