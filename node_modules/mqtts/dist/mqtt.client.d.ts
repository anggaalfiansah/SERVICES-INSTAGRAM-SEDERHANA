/// <reference types="node" />
import { ExecuteDelayed, ExecutePeriodically, IncomingListenMessage, ListenOptions, ListenSubscribeOptions, MqttClientConstructorOptions, MqttSubscription, RegisterClientOptions, Resolvable, StopExecuting, TimerRef } from './mqtt.types';
import { PacketFlowData, PacketFlowFunc } from './flow';
import { MqttParseResult, MqttTransformer } from './mqtt.parser';
import { Transport } from './transport';
import { ConnectRequestOptions, ConnectResponsePacket, DefaultPacketReadResultMap, DefaultPacketWriteOptions, PacketReadResultMap, PacketWriteOptionsMap, PacketWriter, PublishRequestPacket, SubscribeReturnCode } from './packets';
import { MqttMessageOutgoing } from './mqtt.message';
import { Writable } from 'stream';
import { PacketType } from './mqtt.constants';
import { MqttBaseClient } from './mqtt.base-client';
import { HandlerFn, MqttListener, RemoveHandlerFn } from './mqtt.listener';
export declare class MqttClient<ReadMap extends PacketReadResultMap = DefaultPacketReadResultMap, WriteMap extends PacketWriteOptionsMap = DefaultPacketWriteOptions> extends MqttBaseClient<ReadMap, WriteMap> {
    private mqttDebug;
    private receiveDebug;
    private pingDebug;
    protected executePeriodically: ExecutePeriodically;
    protected stopExecuting: StopExecuting;
    protected executeDelayed: ExecuteDelayed;
    protected flowCounter: {
        next(): number;
    } | {
        next(): bigint;
    };
    get keepAlive(): number;
    set keepAlive(value: number);
    protected transport: Transport<unknown>;
    protected transformer: MqttTransformer<ReadMap>;
    protected createTransformer: () => MqttTransformer<ReadMap>;
    protected pipeline?: Writable;
    protected writer: PacketWriter<WriteMap>;
    protected keepAliveTimer?: TimerRef;
    private reconnectStrategy?;
    protected activeFlows: PacketFlowData<any>[];
    protected messageListener: MqttListener;
    constructor(options: MqttClientConstructorOptions<ReadMap, WriteMap>);
    private _connect;
    connect(options?: Resolvable<RegisterClientOptions>): Promise<void>;
    protected createPipeline(): void;
    publish(message: MqttMessageOutgoing): Promise<MqttMessageOutgoing>;
    subscribe(subscription: MqttSubscription): Promise<SubscribeReturnCode>;
    unsubscribe(subscription: MqttSubscription): Promise<void>;
    disconnect(force?: boolean): Promise<void>;
    listenSubscribe<T = IncomingListenMessage>(topic: string, handlerFn: HandlerFn<T>): Promise<RemoveHandlerFn>;
    listenSubscribe<T = IncomingListenMessage, Params extends Record<string, string> = Record<string, string>>(options: ListenSubscribeOptions<T, Params>, handlerFn: HandlerFn<T>): Promise<RemoveHandlerFn>;
    listen<T>(topic: string, handlerFn: HandlerFn<T>): RemoveHandlerFn;
    listen<T, Params extends Record<string, string>>(options: ListenOptions<T, Params>, handlerFn: HandlerFn<T>): RemoveHandlerFn;
    startFlow<T>(flow: PacketFlowFunc<ReadMap, WriteMap, T>): Promise<T> & {
        flowId: bigint | number;
    };
    stopFlow(flowId: bigint | number, rejection?: Error): boolean;
    /**
     *  Run the accept and next function of all active flows
     * @param packet
     * @returns true if a flow has been found
     */
    protected continueFlows(packet: MqttParseResult<ReadMap, typeof PacketType[keyof typeof PacketType]>): boolean;
    protected clearFinishedFlows(): void;
    protected stopExecutingFlows(error: Error): void;
    protected getFlowById<T = any>(id: number | bigint): PacketFlowData<T> | undefined;
    protected registerClient(options: RegisterClientOptions): Promise<any>;
    protected getConnectFlow(options: ConnectRequestOptions): PacketFlowFunc<ReadMap, WriteMap, unknown>;
    protected updateKeepAlive(value: number): void;
    protected sendData(data: Buffer): void;
    protected handlePacket(packet: MqttParseResult<ReadMap, PacketType>): Promise<void>;
    protected onConnAck(connAck: ConnectResponsePacket): void;
    protected onPublish(publish: PublishRequestPacket): void;
    protected onPingReq(): void;
    protected logReceivedPacket(packet: {
        type: PacketType;
        data: any;
    }): void;
    protected reset(): void;
    protected setReady(): void;
    protected reconnect(): Promise<void>;
    protected setDisconnected(reason?: string | Error): Promise<void>;
}
