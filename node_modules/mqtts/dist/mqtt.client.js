"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MqttClient = void 0;
const flow_1 = require("./flow");
const mqtt_parser_1 = require("./mqtt.parser");
const transport_1 = require("./transport");
const packets_1 = require("./packets");
const errors_1 = require("./errors");
const stream_1 = require("stream");
const mqtt_constants_1 = require("./mqtt.constants");
const mqtt_base_client_1 = require("./mqtt.base-client");
const mqtt_listener_1 = require("./mqtt.listener");
const mqtt_utilities_1 = require("./mqtt.utilities");
const debug = require("debug");
const reconnect_strategy_1 = require("./reconnect-strategy");
class MqttClient extends mqtt_base_client_1.MqttBaseClient {
    constructor(options) {
        var _a, _b, _c, _d;
        var _e;
        super();
        this.mqttDebug = debug('mqtt:client');
        this.receiveDebug = this.mqttDebug.extend('packet');
        this.pingDebug = this.mqttDebug.extend('ping');
        // wrapper functions
        this.executePeriodically = (ms, cb) => setInterval(cb, ms);
        this.stopExecuting = ref => clearInterval(ref);
        this.executeDelayed = (ms, cb) => setTimeout(cb, ms);
        this.flowCounter = mqtt_utilities_1.createFlowCounter();
        this.activeFlows = [];
        this.messageListener = new mqtt_listener_1.MqttListener();
        if (typeof options.autoReconnect === 'boolean') {
            this.reconnectStrategy = options.autoReconnect
                ? new reconnect_strategy_1.MqttsReconnectStrategyDefault()
                : new reconnect_strategy_1.MqttsReconnectStrategyDefault(0);
        }
        else {
            this.reconnectStrategy = options.autoReconnect;
        }
        this.transport =
            (_a = options.transport) !== null && _a !== void 0 ? _a : new transport_1.TlsTransport({
                host: options.host,
                port: options.port,
                additionalOptions: {
                    enableTrace: options.enableTrace,
                },
            });
        this.createTransformer =
            (_b = options.createTransformer) !== null && _b !== void 0 ? _b : (() => {
                var _a;
                return new mqtt_parser_1.MqttTransformer({
                    debug: this.mqttDebug.extend('transformer'),
                    mapping: (_a = options.readMap) !== null && _a !== void 0 ? _a : packets_1.DefaultPacketReadMap,
                });
            });
        this.transformer = this.createTransformer();
        (_c = (_e = this.transformer.options).debug) !== null && _c !== void 0 ? _c : (_e.debug = this.mqttDebug.extend('transformer'));
        const packetLogger = this.mqttDebug.extend('write');
        this.writer =
            (_d = options.packetWriter) !== null && _d !== void 0 ? _d : new packets_1.PacketWriter({
                logPacketWrite: mqtt_utilities_1.createDefaultPacketLogger(packetLogger),
            }, options.writeMap);
    }
    get keepAlive() {
        var _a, _b;
        return (_b = (_a = this.connectOptions) === null || _a === void 0 ? void 0 : _a.keepAlive) !== null && _b !== void 0 ? _b : 0;
    }
    set keepAlive(value) {
        if (this.connectOptions) {
            this.connectOptions.keepAlive = value;
            if (value) {
                this.updateKeepAlive(value);
            }
        }
    }
    async _connect(options) {
        var _a;
        this.expectCreated();
        this.mqttDebug(`Connecting using transport "${this.transport.constructor.name}"`);
        this.connectResolver = options;
        this.setConnecting();
        try {
            await this.transport.connect();
        }
        catch (e) {
            this.mqttDebug(`Transport connect error ("${this.transport.constructor.name}")`, e.message);
            const shouldReconnect = (_a = this.reconnectStrategy) === null || _a === void 0 ? void 0 : _a.check();
            await this.setDisconnected(e);
            if (shouldReconnect) {
                return;
            }
            else {
                throw e;
            }
        }
        this.createPipeline();
        return this.registerClient(await this.resolveConnectOptions());
    }
    async connect(options) {
        try {
            await this._connect(options);
        }
        catch (e) {
            this.mqttDebug(`Connection error`, e);
            this.emitError(e);
        }
    }
    createPipeline() {
        if (!this.transport.duplex)
            throw new errors_1.IllegalStateError('Expected transport to expose a Duplex.');
        this.pipeline = stream_1.pipeline(this.transport.duplex, this.transformer, (async (source) => {
            for await (const chunk of source) {
                if (!chunk.type) {
                    throw new Error('Chunk is not a MqttPacket');
                }
                await this.handlePacket(chunk);
            }
            return 'Source drained';
        }) /* bad definitions */, err => {
            if (err)
                this.emitError(err);
            if (!this.disconnected) {
                (err ? this.setDisconnected(err) : this.setDisconnected('Pipeline finished')).catch(e => this.emitWarning(e));
            }
        });
    }
    publish(message) {
        return this.startFlow(flow_1.outgoingPublishFlow(message));
    }
    subscribe(subscription) {
        return this.startFlow(flow_1.outgoingSubscribeFlow(subscription));
    }
    unsubscribe(subscription) {
        return this.startFlow(flow_1.outgoingUnsubscribeFlow(subscription));
    }
    async disconnect(force = false) {
        if (!force) {
            return this.startFlow(flow_1.outgoingDisconnectFlow()).then(async () => {
                await this.setDisconnected('Soft disconnect');
            });
        }
        else {
            await this.setDisconnected('Forced disconnect');
        }
    }
    listenSubscribe(options, handlerFn) {
        const listener = typeof options === 'string' ? { topic: options } : options;
        return this.subscribe({
            ...listener.subscriptionInfo,
            topic: listener.topic.replace(/\/:[A-Za-z-_0-9]+/g, '/+'),
        }).then(() => this.listen(listener, handlerFn));
    }
    listen(options, handlerFn) {
        const listener = typeof options === 'string' ? { topic: options } : options;
        const [topicFilter, paramMatcher] = mqtt_utilities_1.toMqttTopicFilter(listener.topic);
        return this.messageListener.addHandler({
            topicFilter,
            handle: handlerFn,
            transformer: listener.transformer,
            validator: listener.validator,
            paramMatcher,
        });
    }
    startFlow(flow) {
        const flowId = this.flowCounter.next();
        const promise = new Promise((resolve, reject) => {
            const data = {
                resolvers: { resolve, reject },
                finished: false,
                callbacks: flow(value => {
                    data.finished = true;
                    resolve(value);
                }, err => {
                    data.finished = true;
                    reject(err);
                }),
                flowId,
                flowFunc: flow,
            };
            const first = data.callbacks.start();
            if (first)
                this.sendData(this.writer.write(first.type, first.options));
            if (!data.finished) {
                this.activeFlows.push(data);
            }
        });
        promise.flowId = flowId;
        return promise;
    }
    stopFlow(flowId, rejection) {
        const flow = this.getFlowById(flowId);
        if (!flow)
            return false;
        this.activeFlows = this.activeFlows.filter(f => f.flowId !== flowId);
        flow.finished = true;
        flow.resolvers.reject(rejection !== null && rejection !== void 0 ? rejection : new errors_1.FlowStoppedError());
        return true;
    }
    /**
     *  Run the accept and next function of all active flows
     * @param packet
     * @returns true if a flow has been found
     */
    continueFlows(packet) {
        var _a, _b, _c, _d;
        let result = false;
        for (const flow of this.activeFlows) {
            if ((_b = (_a = flow.callbacks).accept) === null || _b === void 0 ? void 0 : _b.call(_a, packet.data)) {
                const next = (_d = (_c = flow.callbacks).next) === null || _d === void 0 ? void 0 : _d.call(_c, packet.data);
                if (next) {
                    this.sendData(this.writer.write(next.type, next.options));
                }
                result = true;
            }
        }
        this.clearFinishedFlows();
        return result;
    }
    clearFinishedFlows() {
        this.activeFlows = this.activeFlows.filter(flow => !flow.finished);
    }
    stopExecutingFlows(error) {
        for (const flow of this.activeFlows) {
            flow.resolvers.reject(error);
            flow.finished = true;
        }
        this.activeFlows = [];
    }
    getFlowById(id) {
        return this.activeFlows.find(f => f.flowId === id);
    }
    registerClient(options) {
        var _a, _b;
        const flow = this.getConnectFlow(options);
        const connectPromiseFlow = this.startFlow(flow);
        if (typeof options.connectDelay !== 'undefined') {
            const timerId = this.executeDelayed((_a = options.connectDelay) !== null && _a !== void 0 ? _a : 2000, () => {
                const flow = this.getFlowById(connectPromiseFlow.flowId);
                if (!flow) {
                    // there's no flow anymore
                    this.stopExecuting(timerId);
                    return;
                }
                const packet = flow.callbacks.start();
                if (packet)
                    this.sendData(this.writer.write(packet.type, packet.options));
            });
            connectPromiseFlow
                .finally(() => this.stopExecuting(timerId))
                // not sure why this is necessary, but it's there so no unhandledRejection is thrown
                .catch(() => undefined);
        }
        (_b = options.signal) === null || _b === void 0 ? void 0 : _b.addEventListener('abort', () => this.stopFlow(connectPromiseFlow.flowId, new errors_1.AbortError('Connecting aborted')));
        return connectPromiseFlow;
    }
    getConnectFlow(options) {
        // assume the defaults are used
        return flow_1.outgoingConnectFlow(options);
    }
    updateKeepAlive(value) {
        value = Math.max(value - 0.5, 1);
        if (this.keepAliveTimer) {
            this.stopExecuting(this.keepAliveTimer);
        }
        this.mqttDebug(`Starting keep-alive-ping {delay: ${value}}`);
        this.keepAliveTimer = this.executePeriodically(value * 1000, () => {
            // assume the defaults are used
            this.startFlow(flow_1.outgoingPingFlow())
                .then(() => this.pingDebug(`PingPong @ ${Date.now()}`))
                .catch(e => {
                this.emitWarning(e);
                this.pingDebug(`PingPong failed. (${e.message})`);
            });
        });
    }
    sendData(data) {
        if (!this.transport.duplex) {
            this.emitError(new errors_1.IllegalStateError('Expected a duplex - was undefined'));
            return;
        }
        this.transport.duplex.write(data);
    }
    async handlePacket(packet) {
        this.logReceivedPacket(packet);
        this.emit(mqtt_constants_1.PacketType[packet.type].toUpperCase(), packet.data);
        let forceCheckFlows = false;
        // The following "type assertions" are valid as clients extending MqttClient have to implement their own methods
        switch (packet.type) {
            case mqtt_constants_1.PacketType.ConnAck: {
                this.onConnAck(packet.data);
                break;
            }
            case mqtt_constants_1.PacketType.Publish: {
                this.onPublish(packet.data);
                break;
            }
            case mqtt_constants_1.PacketType.PingReq: {
                this.onPingReq();
                break;
            }
            case mqtt_constants_1.PacketType.Disconnect: {
                this.setDisconnected('disconnect packet received').catch(e => this.emitWarning(e));
                break;
            }
            default:
                forceCheckFlows = true;
        }
        if (!this.continueFlows(packet) && forceCheckFlows) {
            this.emitWarning(new errors_1.UnexpectedPacketError(mqtt_constants_1.packetTypeToString(packet.type)));
        }
    }
    onConnAck(connAck) {
        var _a, _b;
        if (connAck.isSuccess) {
            this.setReady();
            this.emitConnect(connAck);
            if ((_a = this.connectOptions) === null || _a === void 0 ? void 0 : _a.keepAlive) {
                this.updateKeepAlive(this.connectOptions.keepAlive);
            }
            (_b = this.reconnectStrategy) === null || _b === void 0 ? void 0 : _b.reset();
        }
        else {
            const error = new errors_1.ConnectError(connAck.errorName);
            this.setDisconnected(error).catch(e => this.emitWarning(e));
            this.emitError(error);
        }
    }
    onPublish(publish) {
        var _a;
        this.startFlow(flow_1.incomingPublishFlow({
            topic: publish.topic,
            payload: publish.payload,
            qosLevel: publish.qos,
            retained: publish.retain,
            duplicate: publish.duplicate,
        }, (_a = publish.identifier) !== null && _a !== void 0 ? _a : undefined))
            .then(async (m) => {
            this.emitMessage(m);
            await this.messageListener.handleMessage(m);
        })
            .catch(e => this.emitWarning(e));
    }
    onPingReq() {
        this.startFlow(flow_1.incomingPingFlow())
            .then(() => this.pingDebug(`Server-PingPong @ ${Date.now()}`))
            .catch(e => {
            this.emitWarning(e);
            this.pingDebug(`Server-PingPong failed. (${e.message})`);
        });
    }
    logReceivedPacket(packet) {
        if (packet.type !== mqtt_constants_1.PacketType.PingReq && packet.type !== mqtt_constants_1.PacketType.PingResp)
            this.receiveDebug(`Received ${mqtt_utilities_1.stringifyObject(packet.data)}`);
    }
    reset() {
        super.reset();
        this.stopExecutingFlows(new errors_1.AbortError('Resetting'));
        if (this.keepAliveTimer) {
            clearInterval(this.keepAliveTimer);
            this.keepAliveTimer = undefined;
        }
        this.transformer.reset();
    }
    setReady() {
        super.setReady();
        this.mqttDebug('Ready!');
    }
    async reconnect() {
        var _a, _b;
        this.transport.reset();
        this.transformer = this.createTransformer();
        this.transformer.options.debug = (_a = this.transformer.options.debug) !== null && _a !== void 0 ? _a : this.mqttDebug.extend('transformer');
        await ((_b = this.reconnectStrategy) === null || _b === void 0 ? void 0 : _b.wait());
        await this.connect();
    }
    async setDisconnected(reason) {
        var _a, _b;
        const willReconnect = (_b = (_a = this.reconnectStrategy) === null || _a === void 0 ? void 0 : _a.check(reason)) !== null && _b !== void 0 ? _b : false;
        this.mqttDebug(`Disconnected. Will reconnect: ${willReconnect}`);
        this._setDisconnected();
        this.stopExecutingFlows(new errors_1.AbortError('Client disconnected.'));
        this.emitDisconnect({ reason, reconnect: willReconnect });
        if (this.transport.active) {
            await new Promise(resolve => { var _a, _b; return (_b = (_a = this.transport.duplex) === null || _a === void 0 ? void 0 : _a.end(resolve)) !== null && _b !== void 0 ? _b : resolve(); });
            if (this.transport.duplex && !this.transport.duplex.writableEnded) {
                this.transport.duplex.destroy(new Error('force destroy'));
            }
        }
        this.stopExecuting(this.keepAliveTimer);
        this.reset();
        if (willReconnect) {
            await this.reconnect();
        }
    }
}
exports.MqttClient = MqttClient;
//# sourceMappingURL=mqtt.client.js.map