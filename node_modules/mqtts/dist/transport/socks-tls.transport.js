"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SocksTlsTransport = void 0;
const transport_1 = require("./transport");
const socks_1 = require("socks");
const tls_1 = require("tls");
const errors_1 = require("../errors");
class SocksTlsTransport extends transport_1.Transport {
    constructor(options) {
        super(options);
        this.reset();
    }
    reset() {
        if (this.duplex && !this.duplex.destroyed)
            this.duplex.destroy();
        this.duplex = undefined;
    }
    async connect() {
        if (this.duplex)
            throw new errors_1.IllegalStateError('Still connected.');
        const info = await socks_1.SocksClient.createConnection({
            proxy: this.options.proxyOptions,
            destination: {
                host: this.options.host,
                port: this.options.port,
            },
            command: 'connect',
        });
        return new Promise(res => {
            this.duplex = tls_1.connect({
                ...this.options.additionalOptions,
                socket: info.socket,
                host: this.options.host,
                port: this.options.port,
            }, () => {
                res();
            });
        });
    }
}
exports.SocksTlsTransport = SocksTlsTransport;
//# sourceMappingURL=socks-tls.transport.js.map