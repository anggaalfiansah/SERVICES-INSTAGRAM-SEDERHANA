"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var _attempts;
Object.defineProperty(exports, "__esModule", { value: true });
exports.MqttsReconnectStrategyDefault = void 0;
const errors_1 = require("../errors");
const util_1 = require("util");
const sleep = util_1.promisify(setTimeout);
class MqttsReconnectStrategyDefault {
    constructor(
    /**
     * Maximum attempts amount
     */
    maximum = 60, 
    /**
     * Interval between attempts, milliseconds
     */
    interval = 1000) {
        this.maximum = maximum;
        this.interval = interval;
        /**
         * Internal attempts counter
         */
        _attempts.set(this, 1);
    }
    check(reason) {
        if (reason instanceof errors_1.ConnectError) {
            return ['IdentifierRejected', 'ServerUnavailable'].includes(reason.status);
        }
        if (typeof reason === 'string' && ['Soft disconnect', 'Forced disconnect'].includes(reason)) {
            return false;
        }
        return __classPrivateFieldGet(this, _attempts) <= this.maximum;
    }
    wait() {
        __classPrivateFieldSet(this, _attempts, +__classPrivateFieldGet(this, _attempts) + 1);
        return sleep(this.interval);
    }
    reset() {
        __classPrivateFieldSet(this, _attempts, 1);
    }
}
exports.MqttsReconnectStrategyDefault = MqttsReconnectStrategyDefault;
_attempts = new WeakMap();
//# sourceMappingURL=mqtts.reconnect-strategy.default.js.map