"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PacketStream = void 0;
/*

    Based on: https://github.com/binsoul/net-mqtt/blob/master/src/PacketStream.php
    Last revision: 10-Sep-19

 */
const errors_1 = require("./errors");
class PacketStream {
    constructor(data, length, buffer) {
        this._position = 0;
        this._data = data ? Buffer.from(data) : length ? Buffer.alloc(length) : buffer ? buffer : Buffer.from([]);
        this.position = 0;
    }
    set position(value) {
        this._position = value;
    }
    get position() {
        return this._position;
    }
    get data() {
        return this._data;
    }
    get length() {
        return this._data ? this._data.length : 0;
    }
    get remainingBytes() {
        return this.length - this.position;
    }
    static fromLength(len) {
        return new PacketStream(undefined, len, undefined);
    }
    static fromBuffer(buf) {
        return new PacketStream(undefined, undefined, buf);
    }
    static fromString(data) {
        return new PacketStream(data, undefined, undefined);
    }
    static empty() {
        return new PacketStream(undefined, undefined, undefined);
    }
    static fromHex(hex) {
        return PacketStream.fromBuffer(Buffer.from(hex, 'hex'));
    }
    /**
     *
     * @param {number} steps - steps to move
     * @returns {number} Position before moving
     */
    move(steps = 1) {
        this._position += steps;
        if (this._position > this.length)
            throw new errors_1.EndOfStreamError('Reached end of stream');
        return this._position - steps;
    }
    // General
    seek(len) {
        this.move(len);
        return this;
    }
    cut() {
        this._data = this._data.slice(this._position) || undefined;
        this._position = 0;
        return this;
    }
    // Write
    write(data, move = true) {
        if (this._data)
            this._data = Buffer.concat([this._data, data]);
        else
            this._data = data;
        if (move)
            this.move(data.length);
        return this;
    }
    writeRawString(data) {
        return this.write(Buffer.from(data));
    }
    writeByte(num) {
        this.write(Buffer.from([num]));
        return this;
    }
    writeWord(num) {
        return this.write(Buffer.from([(num & 0xff00) >> 8, num & 0xff]));
    }
    writeString(str) {
        this.writeWord(Buffer.byteLength(str));
        return this.writeRawString(str);
    }
    writeRawAndLength(data) {
        this.writeWord(data.byteLength);
        return this.write(data);
    }
    writeVariableByteInteger(value) {
        let digit = 0;
        do {
            digit = value % 128 | 0;
            value = (value / 128) | 0;
            if (value > 0)
                digit = digit | 0x80;
            this.writeByte(digit);
        } while (value > 0);
        return this;
    }
    // Read
    read(len) {
        if (this.position > this.length || len > this.length - this.position) {
            throw new errors_1.EndOfStreamError(`End of stream reached when trying to read ${len} bytes. content length=${this.length}, position=${this.position}`);
        }
        const buf = this._data.slice(this._position, this.position + len);
        this.move(len);
        return buf;
    }
    readSlice(end) {
        const buf = this._data.slice(this._position, end);
        this.move(buf.length);
        return buf;
    }
    readByte() {
        return this._data.readUInt8(this.move(1));
    }
    readWord() {
        return this._data.readUInt16BE(this.move(2));
    }
    readString() {
        const len = this.readWord();
        return this.read(len).toString('utf8');
    }
    readStringAsBuffer() {
        return this.read(this.readWord());
    }
    readVariableByteInteger() {
        let value = 0;
        let multiplier = 1;
        let encodedByte;
        do {
            encodedByte = this.readByte();
            value += (encodedByte & 0x7f) * multiplier;
            if (multiplier > 128 * 128 * 128) {
                throw new Error(`Invalid variable byte integer ${this.position}/${this.length}; currentValue: ${value}`);
            }
            multiplier *= 0x80;
        } while ((encodedByte & 0x80) !== 0);
        return value;
    }
}
exports.PacketStream = PacketStream;
//# sourceMappingURL=packet-stream.js.map