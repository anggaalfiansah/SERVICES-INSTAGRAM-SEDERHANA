"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MqttTransformer = void 0;
const mqtt_constants_1 = require("./mqtt.constants");
const packet_stream_1 = require("./packet-stream");
const errors_1 = require("./errors");
const stream_1 = require("stream");
const packet_reader_1 = require("./packets/packet-reader");
class MqttTransformer extends stream_1.Transform {
    constructor(options = {}) {
        super({ objectMode: true });
        this.options = options;
        // force the type here
        this.mapping = packet_reader_1.DefaultPacketReadMap;
        this.internalStream = undefined;
        this.mapping = {
            ...this.mapping,
            ...options.mapping,
        };
    }
    _transform(chunk, encoding, callback) {
        var _a, _b;
        if (!Buffer.isBuffer(chunk)) {
            callback(new Error('Expected a Buffer'));
            return;
        }
        const stream = this.internalStream ? this.internalStream.write(chunk, false) : packet_stream_1.PacketStream.fromBuffer(chunk);
        this.internalStream = undefined;
        let startPos = 0;
        while (stream.remainingBytes > 0) {
            const firstByte = stream.readByte();
            const type = (firstByte >> 4);
            const flags = firstByte & 0x0f;
            const packetFn = this.mapping[type];
            if (!packetFn) {
                callback(new errors_1.UnexpectedPacketError(`No packet found for ${type}; @${stream.position - 1} len: ${stream.length}`));
                return;
            }
            let remainingLength = -1;
            try {
                remainingLength = stream.readVariableByteInteger();
                const packet = packetFn(stream, remainingLength, flags);
                this.push({
                    type,
                    data: packet,
                    flags,
                });
                stream.cut();
                startPos = stream.position;
            }
            catch (e) {
                if (e instanceof errors_1.EndOfStreamError) {
                    (_b = (_a = this.options).debug) === null || _b === void 0 ? void 0 : _b.call(_a, `EOS:\n  ${remainingLength} got: ${stream.length} (+) ${chunk.byteLength};\n  return: ${startPos};`);
                    stream.position = startPos;
                    this.internalStream = stream.cut();
                    callback();
                    return;
                }
                else {
                    callback(new errors_1.MalformedPacketError(`Error in parser (type: ${mqtt_constants_1.packetTypeToString(type)}): ${e.message || e} - stream: ${stream.data.toString('base64')}`));
                    return;
                }
            }
        }
        callback();
    }
    reset() {
        this.internalStream = undefined;
    }
}
exports.MqttTransformer = MqttTransformer;
//# sourceMappingURL=mqtt.parser.js.map